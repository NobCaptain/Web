<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h1 id="1-node-js">1.初识Node.js</h1>
<h2 id="1-1-">1.1回顾与思考</h2>
<h3 id="1-1-1-javascript-">1.1.1浏览器中的JavaScript的组成部分</h3>
<ul>
<li><p>浏览器中的JavaScript的组成部分，如下图所示：</p>
<p><img src="imgs/1.png" alt="1"></p>
</li>
</ul>
<h3 id="1-1-2-javascript-">1.1.2为什么JavaScript可以在浏览器中被执行</h3>
<ul>
<li><p>JavaScript可以在浏览器中被执行是因为浏览器使用了JavaScript解析引擎，如下图所示：</p>
<p><img src="imgs/2.png" alt="2"></p>
</li>
<li><p>注意点：</p>
<ul>
<li>不同的浏览器使用的是不同的JavaScript解析引擎，如下所示：<ul>
<li>Chrome浏览器：使用V8解析引擎。</li>
<li>Firefox浏览器：使用OdinMonkey（奥丁猴）解析引擎。</li>
<li>Safri浏览器：使用JSCore解析引擎。</li>
<li>IE浏览器使用：Chakra（查克拉）解析引擎。</li>
</ul>
</li>
<li>V8解析引擎是性能最好的。</li>
</ul>
</li>
</ul>
<h3 id="1-1-3-javascript-dom-bom">1.1.3为什么JavaScript可以操作DOM和BOM</h3>
<ul>
<li><p>JavaScript可以操作DOM和BOM是因为每个浏览器都内置了DOM、BOM这样的API函数，因此浏览器中的JavaScript才可以调用它们，如下图所示：</p>
<p><img src="imgs/3.png" alt="3"></p>
</li>
</ul>
<h3 id="1-1-4-javascript-">1.1.4浏览器中的JavaScript运行环境</h3>
<ul>
<li><p>浏览器中的JavaScript运行环境，如下图所示：</p>
<p><img src="imgs/4.png" alt="4"></p>
<blockquote>
<p>注1：运行环境是指代码正常运行所需的必要环境。</p>
<p>注2：解析引擎：负责解析和执行JavaScript代码。</p>
<p>注3：内置API：由运行环境提供的特殊接口，只能在所属的运行环境中被调用。</p>
</blockquote>
</li>
</ul>
<h3 id="1-1-5javascript-">1.1.5JavaScript能否做后端开发</h3>
<ul>
<li>JavaScript能做后端开发，但是要运行在Node.js的环境下。</li>
</ul>
<h2 id="1-2-node-js">1.2什么是Node.js</h2>
<ul>
<li>Node.js是一个基于Chrome V8引擎的JavaScript运行环境。</li>
<li>Node.js的官方网址：<a href="https://nodejs.org/zh-cn/。">https://nodejs.org/zh-cn/。</a></li>
</ul>
<h2 id="1-3node-js-javascript-">1.3Node.js中的JavaScript运行环境</h2>
<ul>
<li><p>Node.js中的JavaScript运行环境，如下图所示：</p>
<p><img src="imgs/5.png" alt="5"></p>
</li>
<li><p>注意点：浏览器是JavaScript的前端运行环境，而Node.js是JavaScript的后端运行环境，因此在Node.js中是无法调用DOM和BOM等浏览器内置API的。</p>
</li>
</ul>
<h2 id="1-4node-js-">1.4Node.js可以做什么</h2>
<ul>
<li><p>Node.js作为一个JavaScript的运行环境，它仅仅提供了基础的功能和API，然而基于Node.js提供的这些基础功能，很多强大的工具和框架如雨后春笋，层出不穷，所以学会了Node.js，可以让前端程序员胜任更多的工作和岗位。</p>
</li>
<li><p>Node.js可以做的事有以下几种：</p>
<ul>
<li><p>基于Express框架，可以快速构建Web应用。</p>
<blockquote>
<p>注：Express框架的官网地址为：<a href="http://www.expressjs.com.cn/。">http://www.expressjs.com.cn/。</a></p>
</blockquote>
</li>
<li><p>基于Electron框架，可以构建跨平台的桌面应用。</p>
<blockquote>
<p>注：Electron框架的官网地址为：<a href="https://electronjs.org/。">https://electronjs.org/。</a></p>
</blockquote>
</li>
<li><p>基于Restify框架，可以快速构建API接口项目。</p>
<blockquote>
<p>注：Restify框架的官网地址为：<a href="http://restify.com/。">http://restify.com/。</a></p>
</blockquote>
</li>
<li><p>读写和操作数据库、创建实用的命令行工具辅助前端开发等。</p>
</li>
</ul>
</li>
</ul>
<h2 id="1-5node-js-">1.5Node.js怎么学</h2>
<ul>
<li>浏览器中的JavaScript的学习路径是JavaScript基础语法——浏览器内置API（DOM+BOM）——第三方库（jQuery、<code>art-template</code> 等），Node.js的学习路径是JavaScript基础语法——Node.js内置API模块（<code>fs</code>、<code>path</code>、<code>http</code> 等）——第三方API模块（Express、MySQL等）。</li>
</ul>
<h2 id="1-6node-js-">1.6Node.js环境的安装</h2>
<ul>
<li><p>Node.js环境的安装步骤如下：</p>
<ol>
<li><p>下载Node.js，如下图所示：</p>
<p><img src="imgs/6.gif" alt="6"></p>
<blockquote>
<p>注1：Node.js官网地址为：<a href="https://nodejs.org/en/。">https://nodejs.org/en/。</a></p>
<p>注2：上图中可以看到Node.js有两个版本，分别是LTS和Current，这两个版本的区别如下：</p>
<ul>
<li>LTS：为长期稳定版，对于追求稳定性的企业级项目来说，推荐安装LTS版本的Node.js。</li>
<li>Current：为新特性尝鲜版，对热衷于尝试新特性的用户来说，推荐安装Current版本的Node.js，但是Current版本中可能存在隐藏的Bug或安全性漏洞，因此不推荐在企业级项目中使用Current版本的Node.js。</li>
</ul>
</blockquote>
</li>
<li><p>安装Node.js，如下图所示：</p>
<p><img src="imgs/7.gif" alt="7"></p>
<blockquote>
<p>注：查看Node.js有没有安装成功，我们可以在终端中输入 <code>node -v</code> 命令，来查看Node.js的版本号，如果显示了版本号那么就表示Node.js安装成功，在Windows系统下，快速打开终端的方式是使用快捷键（Windows徽标键+R）打开运行面板，输入 <code>cmd</code> 后直接回车，即可打开终端，如下图所示：</p>
<p><img src="imgs/8.gif" alt="8"></p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h2 id="1-7-">1.7什么是终端</h2>
<ul>
<li><p>终端（英文：Terminal）是专门为开发人员设计的，用于实现人机交互的一种方式，在Windows系统下，快速打开终端的方式是使用快捷键（Windows徽标键+R）打开运行面板，输入 <code>cmd</code> 后直接回车，即可打开终端。</p>
</li>
<li><p>终端常用的快捷键如下：</p>
<ul>
<li><p>使用 <code>↑</code> 键，可以快速定位到上一次执行的命令。</p>
</li>
<li><p>使用 <code>Tab</code> 键，能够快速补全路径。</p>
</li>
<li><p>使用 <code>Esc</code> 键，能够快速清空当前已输入的命令。</p>
</li>
<li><p>输入 <code>cls</code> 命令，可以清空终端。</p>
</li>
</ul>
</li>
</ul>
<h2 id="1-8-node-js-javascript-">1.8如何在Node.js环境中执行JavaScript代码</h2>
<ul>
<li><p>在Node.js环境中执行JavaScript代码的步骤如下：</p>
<ol>
<li><p>打开终端，使用 <code>cd 要切换到的路径</code> 命令，将终端路径切换到JavaScript代码文件的目录下，如下图所示：</p>
<p><img src="imgs/9.gif" alt="9"></p>
<blockquote>
<p>注：上图中，因为JavaScript代码文件在D盘中，所以当我们打开终端使用 <code>cd 要切换到的路径</code> 命令时，终端路径切换不到JavaScript代码文件的目录下，是因为终端的默认路径是C盘，所以我们要先使用 <code>d:</code> 命令将终端路径切换到D盘中，才能使用 <code>cd 要切换到的路径</code> 命令，将终端路径切换到JavaScript代码文件的目录下。</p>
</blockquote>
</li>
<li><p>将终端路径切换到JavaScript代码文件的目录下后，使用 <code>node 要执行的JavaScript代码文件的文件名</code> 命令，就可以在Node.js环境中执行JavaScript代码了，如下图所示：</p>
<p><img src="imgs/10.gif" alt="10"></p>
</li>
</ol>
</li>
<li><p>注意点：</p>
<ul>
<li><p>我们可以直接在JavaScript代码文件的目录下使用 <code>Shift+鼠标右键</code> 快捷键，打开快捷菜单，其中有一个在此处打开Powershell窗口选项，鼠标点击该选项就能打开终端，并且该终端的路径已经切换到了JavaScript代码文件的目录下，这样就不需要使用 <code>cd 要切换到的路径</code> 命令，将终端路径切换到JavaScript代码文件的目录下了，如下图所示：</p>
<p><img src="imgs/11.gif" alt="11"></p>
<blockquote>
<p>注：上图中打开的终端是PowerShell终端，而使用快捷键（Windows徽标键+R）打开运行面板，输入 <code>cmd</code> 后直接回车，打开的终端是CMD终端，这两个终端是一样的，它们的区别在于PowerShell终端是CMD终端的升级版，PowerShell终端的功能和性能都比CMD终端，更加强大。</p>
</blockquote>
</li>
<li><p>在Windows11系统下，我们可以直接在JavaScript代码文件的目录下使用鼠标右键，打开快捷菜单，其中有一个在终端打开选项，鼠标点击该选项就能打开PowerShell终端，并且该终端的路径已经切换到了JavaScript代码文件的目录下，这样就不需要使用 <code>cd 要切换到的路径</code> 命令，将终端路径切换到JavaScript代码文件的目录下了，如下图所示：</p>
<p><img src="imgs/12.gif" alt="12"></p>
</li>
</ul>
</li>
</ul>
<h1 id="2-fs-">2.fs文件系统模块</h1>
<h2 id="2-1-fs-">2.1什么是fs文件系统模块</h2>
<ul>
<li>fs模块是Node.js官方提供的、用来操作文件的模块，它提供了一系列的方法和属性，用来满足用户对文件的操作需求，如：它提供了 <code>readFile()</code> 方法，来读取指定文件中的内容，<code>writeFile()</code> 方法，来向指定的文件中写入内容。</li>
<li>注意点：如果要在JavaScript代码中，使用fs模块来操作文件，则需要使用 <code>const fs = require(&#39;fs&#39;);</code> 方式来导入fs模块。</li>
</ul>
<h2 id="2-2-">2.2读取指定文件中的内容</h2>
<ul>
<li><p>我们可以使用fs模块中的 <code>readFile()</code> 方法来读取指定文件中的内容。</p>
</li>
<li><p>语法：</p>
<pre><code class="lang-javascript">const 对象名 = require(&#39;fs&#39;);
对象名.readFile(&#39;path&#39;,[&#39;options&#39;],callback);
</code></pre>
<blockquote>
<p>注：使用fs模块前我们需要先使用 <code>require(&#39;fs&#39;)</code> 方法导入fs模块，导入fs模块后，会将fs模块中的对象返回给 <code>require(&#39;fs&#39;)</code> 方法，因为该对象没有对象名所以需要通过赋值的方式给其赋对象名，然后我们才能使用该对象中的方法。</p>
</blockquote>
</li>
<li><p>取值：</p>
<p>|            | 取值                                             | 作用                             |
| :--------: | ------------------------------------------------ | :------------------------------- |
|   对象名   | 用户自定义，要遵从变量名的命名规则与规范         |                                  |
|   <code>path</code>   | 用户自定义，只能是要读取指定文件时，该文件的路径 | 设置要读取那个文件               |
| <code>options</code>  | 用户自定义，只能是编码格式，如：<code>utf8</code> 等        | 设置以什么编码格式来读取文件     |
| <code>callback</code> | 用户自定义，只能是匿名函数                       | 设置读取文件后，要执行的回调函数 |</p>
</li>
<li><p>注意点：</p>
<ul>
<li><code>对象名.readFile(&#39;path&#39;,[&#39;options&#39;],callback)</code> 方法中被中括号包裹起来的参数可写可不写。</li>
<li>当使用 <code>对象名.readFile(&#39;path&#39;,[&#39;options&#39;],callback)</code> 方法读取文件时，会将是否读取成功的结果和读取的内容，传递给回调函数，所以回调函数的括号内的第一个形参中存储的就是是否读取成功的信息，第二形参中存储的就是读取的内容，一般我们会将回调函数的括号内的第一个形参的名字设置为 <code>err</code>，第二个形参的名字设置为 <code>dataStr</code>。</li>
<li>当使用 <code>对象名.readFile(&#39;path&#39;,[&#39;options&#39;],callback)</code> 方法读取文件时，如果读取成功了就会传递 <code>null</code> 给回调函数的第一个形参，传递读取的内容给第二个形参，如果读取失败了就会传递一个错误对象给回调函数的第一个形参，传递 <code>undefined</code> 给第二个形参，并且该错误对象的对象名就是第一个形参的形参名，并且该错误对象中有一个 <code>message</code> 属性，该属性存储的是错误信息。</li>
</ul>
</li>
<li><p>演示代码之要读取的文件：</p>
<pre><code>// 01-读取指定文件中的内容.txt
123
</code></pre></li>
<li><p>演示代码之JavaScript代码文件：</p>
<pre><code class="lang-javascript">// 01-读取指定文件中的内容.js
const fs = require(&#39;fs&#39;);
fs.readFile(&#39;./files/01-读取指定文件中的内容.txt&#39;,&#39;utf8&#39;,(err,dataStr) =&gt; {
    console.log(err);
    console.log(dataStr);
});
fs.readFile(&#39;./files/02-读取指定文件中的内容.txt&#39;,&#39;utf8&#39;,(err,dataStr) =&gt; {
    if (err) {
        console.log(`错误信息：${err.message}`);
    }
    console.log(dataStr);
});
</code></pre>
</li>
<li><p>演示结果：</p>
<p><img src="imgs/13.gif" alt="13"></p>
</li>
</ul>
<h2 id="2-3-">2.3向指定文件中写入内容</h2>
<ul>
<li><p>我们可以使用fs模块中的 <code>writeFile()</code> 方法来向指定文件中写入内容。</p>
</li>
<li><p>语法：</p>
<pre><code class="lang-javascript">const 对象名 = require(&#39;fs&#39;);
对象名.writeFile(&#39;path&#39;,data,[&#39;options&#39;],callback);
</code></pre>
<blockquote>
<p>注：使用fs模块前我们需要先使用 <code>require(&#39;fs&#39;)</code> 方法导入fs模块，导入fs模块后，会将fs模块中的对象返回给 <code>require(&#39;fs&#39;)</code> 方法，因为该对象没有对象名所以需要通过赋值的方式给其赋对象名，然后我们才能使用该对象中的方法。</p>
</blockquote>
</li>
<li><p>取值：</p>
<p>|            | 取值                                                       | 作用                                     |
| :--------: | ---------------------------------------------------------- | :--------------------------------------- |
|   对象名   | 用户自定义，要遵从变量名的命名规则与规范                   |                                          |
|   <code>path</code>   | 用户自定义，只能是要向指定文件中写入内容时，该文件的路径   | 设置要向那个文件写入内容                 |
|   <code>data</code>   | 用户自定义，可以是数字、字符串等                           | 设置要向文件中写入什么内容               |
| <code>options</code>  | 用户自定义，只能是编码格式，如：<code>utf8</code> 等，默认值为 <code>utf8</code> | 设置以什么编码格式来向文件中写入内容     |
| <code>callback</code> | 用户自定义，只能是匿名函数                                 | 设置向文件中写入内容后，要执行的回调函数 |</p>
</li>
<li><p>注意点：</p>
<ul>
<li><code>对象名.writeFile(&#39;path&#39;,data,[&#39;options&#39;],callback)</code> 方法中被中括号包裹起来的参数可写可不写。</li>
<li>当使用 <code>对象名.writeFile(&#39;path&#39;,data,[&#39;options&#39;],callback)</code> 方法向文件中写入内容时，会将是否写入成功的结果，传递给回调函数，所以回调函数的括号内的第一个形参中存储的就是是否写入成功的信息，一般我们会将回调函数的括号内的第一个形参的名字设置为 <code>err</code>。</li>
<li>当使用 <code>对象名.writeFile(&#39;path&#39;,data,[&#39;options&#39;],callback)</code> 方法向文件中写入内容时，如果写入成功了就会传递 <code>null</code> 给回调函数的第一个形参，如果写入失败了就会传递一个错误对象给回调函数的第一个形参，并且该错误对象的对象名就是第一个形参的形参名。</li>
<li>当使用 <code>对象名.writeFile(&#39;path&#39;,data,[&#39;options&#39;],callback)</code> 方法向文件中写入内容时，如果该文件中有内容，那么这些内容会被删除掉。</li>
<li>当使用 <code>对象名.writeFile(&#39;path&#39;,data,[&#39;options&#39;],callback)</code> 方法向文件中写入内容时，如果该文件不存在，但是该文件的路径存在，那么就会在该路径上创建一个新的文件，然后将其内容写入。</li>
<li>当使用 <code>对象名.writeFile(&#39;path&#39;,data,[&#39;options&#39;],callback)</code> 方法向文件中写入内容时，如果该文件不存在，并且该文件的路径也不存在，那么就会写入失败。</li>
</ul>
</li>
<li><p>演示代码之要写入的文件：</p>
<pre><code>// 02-向指定文件中写入内容.txt
123
</code></pre></li>
<li><p>演示代码之JavaScript代码文件：</p>
<pre><code class="lang-javascript">// 02-向指定文件中写入内容.js
const fs = require(&#39;fs&#39;);
fs.writeFile(&#39;./files/02-向指定文件中写入内容.txt&#39;,&#39;abcd&#39;,(err) =&gt; {
    console.log(err);
});
fs.writeFile(&#39;f:\files\02-向指定文件中写入内容.txt&#39;,&#39;abcd&#39;,(err) =&gt; {
    if (err) {
        return console.log(&#39;写入文件失败&#39;);
    }
    console.log(&#39;写入文件成功&#39;);
});
</code></pre>
</li>
<li><p>演示结果：</p>
<p><img src="imgs/14.gif" alt="14"></p>
</li>
</ul>
<h2 id="2-4-">2.4成绩处理案例</h2>
<ul>
<li><p>使用fs文件系统模块，将成绩.txt文件中的考试数据，整理到成绩-ok.txt文件中。</p>
</li>
<li><p>整理前，成绩.txt文件中的数据格式如下：</p>
<pre><code>小红=99 小黑=88 小蓝=77 小紫=66 小星=55
</code></pre></li>
<li><p>整理完成之后，希望得到的成绩-ok.txt文件中的数据格式如下：</p>
<pre><code>小红：99
小黑：88
小蓝：77
小紫：66
小星：55
</code></pre></li>
<li><p>成绩处理案例的实现步骤：</p>
<ol>
<li>导入fs文件系统模块。</li>
<li>使用 <code>readFile()</code> 方法，读取成绩.txt文件中的考试数据。</li>
<li>判断文件是否读取失败。</li>
<li>文件读取成功后，处理成绩数据。</li>
<li>将处理完成的成绩数据，调用 <code>fs.writeFile()</code> 方法，写入到新文件成绩-ok.txt中。</li>
</ol>
</li>
<li><p>演示代码：</p>
<pre><code class="lang-javascript">// 导入fs文件系统模块。
const fs = require(&#39;fs&#39;);
// 使用readFile()方法，读取成绩.txt文件中的考试数据。
fs.readFile(&#39;./files/成绩单.txt&#39;,&#39;utf8&#39;,(err,dataStr) =&gt; {
    // 判断文件是否读取失败。
    if (err) {
        return console.log(`读取文件失败：${err.message}`);
    }
    // 文件读取成功后，处理成绩数据。
    const oldArr = dataStr.split(&#39; &#39;);
    const newArr = [];
    oldArr.forEach(ele =&gt; {
        newArr.push(ele.replace(&#39;=&#39;,&#39;：&#39;));
    });
    const str = newArr.join(&#39;\r\n&#39;);
    // 将处理完成的成绩数据，调用fs.writeFile()方法，写入到新文件成绩-ok.txt中。
    fs.writeFile(&#39;./files/成绩-ok.txt&#39;,str,err =&gt; {
        if (err) {
            return console.log(&#39;写入失败&#39;);
        }
        console.log(&#39;写入成功&#39;);
    });
});
</code></pre>
</li>
<li><p>演示结果：</p>
<p><img src="imgs/15.gif" alt="15"></p>
</li>
</ul>
<h2 id="2-5fs-">2.5fs模块路径拼接问题</h2>
<ul>
<li><p>在使用fs模块操作文件时，如果提供的文件路径是以 <code>./</code> 或 <code>../</code> 开头的相对路径时，就会很容易出现路径动态拼接错误的问题，出现这个问题的原因是代码在运行的时候，会以执行 <code>node 要执行的JavaScript代码文件的文件名</code> 命令时所处的目录，动态拼接出被操作文件的完整路径，如以下代码所示：</p>
<pre><code class="lang-javascript">const fs = require(&#39;fs&#39;);
fs.writeFile(&#39;./files/02-向指定文件中写入内容.txt&#39;,&#39;abcd&#39;,(err) =&gt; {
    console.log(err);
});
</code></pre>
<blockquote>
<p>注：以上代码的文件的路径为 <code>C:\user\JavaScript代码文件.js</code>，被操作文件的路径为 <code>C:\user\files\02-向指定文件中写入内容.txt</code>，当我们使用终端执行 <code>node JavaScript代码文件.js</code> 命令，并且终端所处的目录是JavaScript代码文件的目录下时，会动态拼接出 <code>C:\user\files\02-向指定文件中写入内容.txt</code> 路径，而该路径又是被操作文件的完整路径，所以以上代码可以操作该文件，但是如果终端所处的目录不是JavaScript代码文件的目录下时，那么就拼接不出被操作文件的完整路径，如：如果终端所处的目录是 <code>C:</code>，那么当我们使用终端执行 <code>node .\user\JavaScript代码文件.js</code> 命令时，会动态拼接出 <code>C:\files\02-向指定文件中写入内容.txt</code> 路径，而该路径不是被操作文件的完整路径，所以以上代码就不可以操作该文件了。</p>
</blockquote>
</li>
<li><p>我们可以在使用fs模块操作文件时，直接提供被操作文件的完整路径，不要提供 <code>./</code> 或 <code>../</code> 开头的相对路径，从而防止路径动态拼接的问题，如以下代码所示：</p>
<pre><code class="lang-javascript">const fs = require(&#39;fs&#39;);
fs.writeFile(&#39;C:\\user\\files\\02-向指定文件中写入内容.txt&#39;,&#39;abcd&#39;,(err) =&gt; {
    console.log(err);
});
</code></pre>
<blockquote>
<p>注：因为在JavaScript中单个 <code>\</code> 表示转义的意思，所以被操作文件的完整路径中的 <code>\</code> 要使用 <code>\\</code> 来表示。</p>
</blockquote>
</li>
<li><p>当我们使用上面的方法来防止动态拼接的问题时，会导致移植性非常差，不利于维护，这是因为我们在使用fs模块操作文件时，直接提供了被操作文件的完整路径，这时如果我们移动了被操作的文件时，就会发生报错，这就导致了移植性非常差，不利于维护，但是我们可以使用 <code>__dirname</code> 来解决这个问题，在Node.js中 <code>__dirname</code> 表示当前JavaScript代码文件的路径，也就是说在那个JavaScript代码文件中写上了 <code>__dirname</code>，<code>__dirname</code> 就表示当前文件所在的路径，然后再将其与被操作文件的路径进行拼接就可以防止路径动态拼接的问题，并且不会导致移植性非常差，不利于维护，如以下代码所示：</p>
<pre><code class="lang-javascript">const fs = require(&#39;fs&#39;);
fs.writeFile(&#39;__dirname + /files/02-向指定文件中写入内容.txt&#39;,&#39;abcd&#39;,(err) =&gt; {
    console.log(err);
});
</code></pre>
</li>
</ul>
<h1 id="3-path-">3.path路径模块</h1>
<h2 id="3-1-path-">3.1什么时path路径模块</h2>
<ul>
<li>path模块是Node.js官方提供的、用来处理路径的模块，它提供了一系列的方法和属性，用来满足用户对路径的处理需求，如：它提供了 <code>join()</code> 方法来将多个路径片段拼接成一个完整的路径字符串，<code>basename()</code> 方法来从路径字符串中，将文件名解析出来。</li>
<li>注意点：如果要在JavaScript代码中，使用path模块来处理路径，则需要使用 <code>const path = require(&#39;path&#39;);</code> 方式来导入path模块。</li>
</ul>
<h2 id="3-2-">3.2拼接路径</h2>
<ul>
<li><p>我们可以使用path模块中的 <code>join()</code> 方法来拼接路径。</p>
</li>
<li><p>语法：</p>
<pre><code class="lang-javascript">const 对象名 = require(&#39;path&#39;);
对象名.join(&#39;要拼接的路径1&#39;,&#39;要拼接的路径2&#39;,···,&#39;要拼接的路径n&#39;);
</code></pre>
<blockquote>
<p>注：使用path模块前我们需要先使用 <code>require(&#39;path&#39;)</code> 方法导入path模块，导入path模块后，会将path模块中的对象返回给 <code>require(&#39;path&#39;)</code> 方法，因为该对象没有对象名所以需要通过赋值的方式给其赋对象名，然后我们才能使用该对象中的方法。</p>
</blockquote>
</li>
<li><p>取值：</p>
<p>|              | 取值                                     | 作用                   |
| :----------: | ---------------------------------------- | :--------------------- |
|    对象名    | 用户自定义，要遵从变量名的命名规则与规范 |                        |
| 要拼接的路径 | 用户自定义，只能是路径                   | 设置那几个路径进行拼接 |</p>
</li>
<li><p>注意点：</p>
<ul>
<li>如果 <code>对象名.join(&#39;要拼接的路径1&#39;,&#39;要拼接的路径2&#39;,···,&#39;要拼接的路径n&#39;)</code> 方法中有一个要拼接的路径是 <code>../</code> 就表示返回上一层目录，如：<code>path.join(&#39;a/b/c&#39;,&#39;../&#39;,&#39;/d&#39;)</code> 代码输出的路径是 <code>a\b\d</code>。</li>
<li>今后凡是涉及到路径拼接的操作，都要使用 <code>join()</code> 方法进行处理，不要直接使用 <code>+</code> 进行字符串拼接。</li>
<li><code>对象名.join(&#39;要拼接的路径1&#39;,&#39;要拼接的路径2&#39;,···,&#39;要拼接的路径n&#39;)</code> 方法执行完毕后会返回拼接好的路径给 <code>对象名.join(&#39;要拼接的路径1&#39;,&#39;要拼接的路径2&#39;,···,&#39;要拼接的路径n&#39;)</code> 方法。</li>
</ul>
</li>
<li><p>演示代码：</p>
<pre><code class="lang-javascript">const path = require(&#39;path&#39;);
console.log(path.join(&#39;/a&#39;,&#39;/b/c&#39;,&#39;../&#39;,&#39;/d&#39;));
</code></pre>
</li>
<li><p>演示结果：</p>
<p><img src="imgs/16.gif" alt="16"></p>
</li>
</ul>
<h2 id="3-3-">3.3获取路径中的文件名</h2>
<ul>
<li><p>我们可以使用path模块中的 <code>basename()</code> 方法来获取路径中的最后一部分，我们经常通过这个方法来获取路径中的文件名。</p>
</li>
<li><p>语法：</p>
<pre><code class="lang-javascript">const 对象名 = require(&#39;path&#39;);
对象名.basename(&#39;path&#39;,[&#39;ext&#39;]);
</code></pre>
<blockquote>
<p>注：使用path模块前我们需要先使用 <code>require(&#39;path&#39;)</code> 方法导入path模块，导入path模块后，会将path模块中的对象返回给 <code>require(&#39;path&#39;)</code> 方法，因为该对象没有对象名所以需要通过赋值的方式给其赋对象名，然后我们才能使用该对象中的方法。</p>
</blockquote>
</li>
<li><p>取值：</p>
<p>|        | 取值                                             | 作用                                   |
| :----: | ------------------------------------------------ | :------------------------------------- |
| 对象名 | 用户自定义，要遵从变量名的命名规则与规范         |                                        |
| <code>path</code> | 用户自定义，只能是路径                           | 设置获取那个路径中的文件名             |
| <code>ext</code>  | 用户自定义，只能是要获取的文件名，该文件的拓展名 | 设置获取文件名时，该文件名不包含拓展名 |</p>
</li>
<li><p>注意点：<code>对象名.basename(&#39;path&#39;,[&#39;ext&#39;])</code> 方法中被中括号包裹起来的参数可写可不写。</p>
</li>
<li><p>演示代码：</p>
<pre><code class="lang-javascript">const path = require(&#39;path&#39;);
const str = &#39;./a/b/c/index.html&#39;;
console.log(path.basename(str));
console.log(path.basename(str,&#39;.html&#39;));
</code></pre>
</li>
<li><p>演示结果：</p>
<p><img src="imgs/17.gif" alt="17"></p>
</li>
</ul>
<h2 id="3-4-">3.4获取路径中的文件的扩展名</h2>
<ul>
<li><p>我们可以使用path模块中的 <code>extname()</code> 方法来获取路径中的文件的扩展名部分。</p>
</li>
<li><p>语法：</p>
<pre><code class="lang-javascript">const 对象名 = require(&#39;path&#39;);
对象名.extname(&#39;path&#39;);
</code></pre>
</li>
<li><p>取值：</p>
<p>|        | 取值                                     | 作用                                 |
| :----: | ---------------------------------------- | :----------------------------------- |
| 对象名 | 用户自定义，要遵从变量名的命名规则与规范 |                                      |
| <code>path</code> | 用户自定义，只能是路径                   | 设置获取那个路径中的文件的拓展名部分 |</p>
</li>
<li><p>演示代码：</p>
<pre><code class="lang-javascript">const path = require(&#39;path&#39;);
const str = &#39;./a/b/c/index.html&#39;;
console.log(path.extname(str));
</code></pre>
</li>
<li><p>演示结果：</p>
<p><img src="imgs/18.gif" alt="18"></p>
</li>
</ul>
<h2 id="3-5-">3.5拆分时钟案例</h2>
<ul>
<li><p>将以下代码拆分成 <code>clock.css</code>、<code>clock.js</code>、<code>clock.html</code> 三个文件。</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
  &lt;title&gt;index首页&lt;/title&gt;
  &lt;style&gt;
    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      background-image: linear-gradient(to bottom right, red, gold);
    }
    .box {
      width: 400px;
      height: 250px;
      background-color: rgba(255, 255, 255, 0.6);
      border-radius: 6px;
      position: absolute;
      left: 50%;
      top: 40%;
      transform: translate(-50%, -50%);
      box-shadow: 1px 1px 10px #fff;
      text-shadow: 0px 1px 30px white;
      display: flex;
      justify-content: space-around;
      align-items: center;
      font-size: 70px;
      user-select: none;
      padding: 0 20px;
      /* 盒子投影 */
      -webkit-box-reflect: below 0px -webkit-gradient(linear, left top, left bottom, from(transparent), color-stop(0%, transparent), to(rgba(250, 250, 250, .2)));
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div class=&quot;box&quot;&gt;
    &lt;div id=&quot;HH&quot;&gt;00&lt;/div&gt;
    &lt;div&gt;:&lt;/div&gt;
    &lt;div id=&quot;mm&quot;&gt;00&lt;/div&gt;
    &lt;div&gt;:&lt;/div&gt;
    &lt;div id=&quot;ss&quot;&gt;00&lt;/div&gt;
  &lt;/div&gt;
  &lt;script&gt;
    window.onload = function () {
      // 定时器，每隔 1 秒执行 1 次
      setInterval(() =&gt; {
        var dt = new Date()
        var HH = dt.getHours()
        var mm = dt.getMinutes()
        var ss = dt.getSeconds()
        // 为页面上的元素赋值
        document.querySelector(&#39;#HH&#39;).innerHTML = padZero(HH)
        document.querySelector(&#39;#mm&#39;).innerHTML = padZero(mm)
        document.querySelector(&#39;#ss&#39;).innerHTML = padZero(ss)
      }, 1000)
    }
    // 补零函数
    function padZero(n) {
      return n &gt; 9 ? n : &#39;0&#39; + n
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
<li><p>拆分时钟案例的实现步骤：</p>
<ol>
<li>导入fs模块。</li>
<li>导入path模块。</li>
<li>创建两个正则表达式，分别用来匹配 <code>&lt;style&gt;</code> 和 <code>&lt;script&gt;</code> 标签。</li>
<li>使用fs模块，读取需要被处理的文件。</li>
<li>自定义resolveCSS方法，来写入index.css样式文件。</li>
<li>自定义resolveJS方法，来写入index.js脚本文件。</li>
<li>自定义resolveHTML方法，来写入index.html文件。</li>
</ol>
</li>
<li><p>演示代码：</p>
<pre><code class="lang-javascript">// 导入fs模块。
const fs = require(&#39;fs&#39;);
// 导入path模块。
const path = require(&#39;path&#39;);
// 创建两个正则表达式，分别用来匹配&lt;style&gt;和&lt;script&gt;标签。
const regStyle = /&lt;style&gt;[\s\S]*&lt;\/style&gt;/;
const regScript = /&lt;script&gt;[\s\S]*&lt;\/script&gt;/;
// 使用fs模块，读取需要被处理的文件。
fs.readFile(path.join(__dirname,&#39;./index.html&#39;),&#39;utf8&#39;,(err,dataStr) =&gt; {
    if (err) {
        return console.log(`读取文件失败：${err.message}`);
    }
    resolveCSS(dataStr);
    resolveJS(dataStr);
    resolveHTML(dataStr);
});
// 自定义resolveCSS方法，来写入index.css样式文件。
function resolveCSS(data) {
    const arr = regStyle.exec(data);
    const newStr = arr[0].replace(&#39;&lt;style&gt;&#39;,&#39;&#39;).replace(&#39;&lt;/style&gt;&#39;,&#39;&#39;);
    fs.writeFile(path.join(__dirname,&#39;./clock/clock.css&#39;),newStr,err =&gt; {
        if (err) {
            return console.log(&#39;写入文件失败&#39;);
        }
        console.log(&#39;写入文件成功&#39;);
    });
}
// 自定义resolveJS方法，来写入index.js脚本文件。
function resolveJS(data) {
    const arr = regScript.exec(data);
    const newStr = arr[0].replace(&#39;&lt;script&gt;&#39;,&#39;&#39;).replace(&#39;&lt;/script&gt;&#39;,&#39;&#39;);
    fs.writeFile(path.join(__dirname,&#39;./clock/clock.js&#39;),newStr,err =&gt; {
        if (err) {
            return console.log(&#39;写入文件失败&#39;);
        }
        console.log(&#39;写入文件成功&#39;);
    });
}
// 自定义resolveHTML方法，来写入index.html文件。
function resolveHTML(data) {
    const newStr = data.replace(regStyle,&#39;&lt;link rel=&quot;stylesheet&quot; href=&quot;./clock.css&quot;&gt;&#39;).replace(regScript,&#39;&lt;script src=&quot;./clock.js&quot;&gt;&lt;/script&gt;&#39;);
    fs.writeFile(path.join(__dirname,&#39;./clock/clock.html&#39;),newStr,err =&gt; {
        if (err) {
            return console.log(&#39;写入文件失败&#39;);
        }
        console.log(&#39;写入文件成功&#39;);
    });
}
</code></pre>
</li>
<li><p>演示结果：</p>
<p><img src="imgs/19.gif" alt="19"></p>
</li>
</ul>
<h1 id="4-http-">4.http模块</h1>
<h2 id="4-1-http-">4.1什么是http模块</h2>
<ul>
<li>在网络节点中，负责消费资源的电脑，我们叫做客户端，而负责对外提供网络资源的电脑，我们叫做服务器，而http模块是Node.js官方提供的、用来创建Web服务器的模块，我们通过http模块提供的 <code>createServer()</code> 方法，就能很方便的把一台普通的电脑，变成一台Web服务器，从而对外提供Web资源服务。</li>
<li>注意点：如果要在JavaScript代码中，使用http模块来创建Web服务器，则需要使用 <code>const http = require(&#39;http&#39;);</code> 方式来导入http模块。</li>
</ul>
<h2 id="4-2-http-">4.2进一步理解http模块的作用</h2>
<ul>
<li>服务器和普通电脑的区别在于，服务器上安装了Web服务器软件，如：IIS、Apache等，我们通过安装这些服务器软件，就能把一台普通的电脑变成一台Web服务器，但是在Node.js中，我们不需要使用IIS、Apache等这些第三方Web服务器软件，因为我们可以基于Node.js提供的http模块，通过几行简单的代码，就能轻松的手写一个服务器软件，从而对外提供Web服务。</li>
</ul>
<h2 id="4-3-">4.3服务器相关的概念</h2>
<h3 id="4-3-1ip-">4.3.1IP地址</h3>
<ul>
<li><p>IP地址就是互联网上每台计算机的唯一地址，因此IP地址具有唯一性，如果把个人电脑比作一台电话的话，那么IP地址就相当于电话号码，只有在知道对方IP地址的前提下，我们才能与对应的电脑之间进行数据通信。</p>
<blockquote>
<p>注：IP地址的格式通常用点分十进制表示成 <code>a.b.c.d</code> 的形式，其中a，b，c，d都是0~255之间的十进制整数，如：用点分十进表示的IP地址 <code>192.168.1.1</code>。</p>
</blockquote>
</li>
<li><p>注意点：</p>
<ul>
<li><p>互联网中每台Web服务器，都有自己的IP地址，如：我们可以在Windows的终端中运行 <code>ping www.baidu.com</code> 命令，即可查看到百度服务器的IP地址，并且还可以通过该IP地址来访问百度服务器。</p>
</li>
<li><p>在使用Node.js开发期间，如果使用了http模块，让自己的电脑既是一台服务器，也是一个客户端，那么为了方便测试，我们可以在自己的浏览器中输入 <code>127.0.0.1</code> 这个IP地址，就能把自己的电脑当做一台服务器进行访问了，如下图所示：</p>
</li>
</ul>
</li>
</ul>
<h3 id="4-3-2-">4.3.2域名与域名服务器</h3>
<ul>
<li>尽管IP地址能够唯一地标记网络上的计算机，但是IP地址是一长串数字，这就导致了不直观，而且不便于记忆，于是人们又发明了另一套字符型的地址方案，即所谓的域名（Domain Name）地址，如：百度的域名地址就是<a href="http://www.baidu.com，IP地址和域名是一一对应的关系，这份对应关系存放在一种叫做域名服务器（DNS，Domain">www.baidu.com，IP地址和域名是一一对应的关系，这份对应关系存放在一种叫做域名服务器（DNS，Domain</a> name server）的电脑中，使用者只需通过好记的域名访问对应的服务器即可，对应的转换工作由域名服务器来实现，因此域名服务器就是提供IP地址和域名之间的转换服务的服务器。</li>
<li>注意点：<ul>
<li>单纯的使用IP地址，在互联网中的电脑也能够正常工作，但是有了域名的加持，就能让互联网的世界变得更加方便。</li>
<li>在使用Node.js开发期间，如果使用了http模块，让自己的电脑既是一台服务器，也是一个客户端，那么为了方便测试，我们可以在自己的浏览器中输入 <code>localhost</code> 这个域名地址，就能把自己的电脑当做一台服务器进行访问了，因此 <code>127.0.0.1</code> IP地址对应的域名是 <code>localhost</code>，它们都代表我们自己的这台电脑，在使用效果上没有任何区别。</li>
</ul>
</li>
</ul>
<h3 id="4-3-3-">4.3.3端口号</h3>
<ul>
<li><p>计算机中的端口号，就好像是现实生活中的门牌号一样，外面小哥通过门牌号就可以在整栋大楼的众多的房间中，准确的把外卖送到你的手中，同样的道理，在一台电脑中，可以运行成百上千个Web服务，每个Web服务都对应着一个唯一的端口号，客户端发送过来的网络请求，通过端口号，就可以被准确地交给对应的Web服务进行处理，如下图所示：</p>
<p><img src="imgs/20.png" alt="20"></p>
</li>
<li><p>注意点：</p>
<ul>
<li>每个端口号不能同时被多个Web服务占用。</li>
<li>在客户端发起请求的URL地址中，如果端口号是80，那么URL地址中的80端口号就可以省略不写，但是要注意只有80端口号可以省略不写。</li>
</ul>
</li>
</ul>
<h2 id="4-4-web-">4.4创建最基本的Web服务器</h2>
<ul>
<li><p>创建最基本的Web服务器的步骤如下：</p>
<ol>
<li><p>导入http模块，如以下代码所示：</p>
<pre><code class="lang-javascript">const http = require(&#39;http&#39;);
</code></pre>
<blockquote>
<p>注：使用http模块前我们需要先使用 <code>require(&#39;http&#39;)</code> 方法导入http模块，导入http模块后，会将http模块中的对象返回给 <code>require(&#39;http&#39;)</code> 方法，因为该对象没有对象名所以需要通过赋值的方式给其赋对象名，然后我们才能使用该对象中的方法。</p>
</blockquote>
</li>
<li><p>使用http模块中的 <code>createServer()</code> 方法来创建Web服务器，如以下代码所示：</p>
<pre><code class="lang-javascript">const http = require(&#39;http&#39;);
const server = http.createServer();
</code></pre>
<blockquote>
<p>注：使用http模块中的 <code>createServer()</code> 方法来创建Web服务器后，会返回Web服务器对象给 <code>createServer()</code> 方法，因为该对象没有对象名所以需要通过赋值的方式给其赋对象名，然后我们才能使用该对象中的方法。</p>
</blockquote>
</li>
<li><p>使用Web服务器对象中的 <code>on()</code> 方法来给Web服务器添加 <code>request</code> 事件，如以下代码所示：</p>
<pre><code class="lang-javascript">const http = require(&#39;http&#39;);
const server = http.createServer();
server.on(&#39;request&#39;,(req,res) =&gt; {
    const str = `Your request url is ${req.url},and request method is ${req.method}`;
    res.end(str);
});
</code></pre>
<blockquote>
<p>注：<code>request</code> 事件是只要客户端请求了Web服务器，就会触发 <code>request</code> 事件，从而调用这个事件的要执行的函数，并且在触发 <code>request</code> 事件后，会将请求对象和响应对象传递给要执行的函数，所以要执行的函数的第一个形参存储的是请求对象，并且该请求对象的对象名就是第一个形参的形参名，第二个形参存储的是响应对象，并且该响应对象的对象名就是第二个形参的形参名，一般我们会将回调函数的括号内的第一个形参的名字设置为 <code>req</code>，第二个形参的名字设置为 <code>res</code>，其中请求对象包含了与客户端相关的数据和属性，如：请求对象中的 <code>url</code> 属性，存储的是客户端请求的URL地址端口号后面的URL地址，<code>method</code> 属性存储的是客户端请求的请求方式，响应对象包含了与服务器相关的数据和属性，如：要发送到客户端的字符串，并且还可以使用响应对象中的 <code>end()</code> 方法来向客户端发送指定的内容，并结束这次请求的处理过程。</p>
</blockquote>
</li>
<li><p>使用Web服务器对象中的 <code>listen()</code> 方法来启动Web服务器，如以下代码所示：</p>
<pre><code class="lang-javascript">const http = require(&#39;http&#39;);
const server = http.createServer();
server.on(&#39;request&#39;,(req,res) =&gt; {
    const str = `Your request url is ${req.url},and request method is ${req.method}`;
    res.end(str);
});
server.listen(80,() =&gt; {
    console.log(&#39;http server runing at http://127.0.0.1&#39;);
});
</code></pre>
<blockquote>
<p>注：<code>listen()</code> 方法中的第一个参数是设置启动Web服务器时，使用的端口号，第二个参数是回调函数，该回调函数在Web服务器启动成功后就会被调用。</p>
</blockquote>
</li>
<li><p>使用VSCode编译器中的终端来运行 <code>node 要执行的JavaScript代码文件的文件名</code> 命令，让创建最基本的Web服务器代码运行在Node.js环境中，如下图所示：</p>
<p><img src="imgs/21.gif" alt="21"></p>
<blockquote>
<p>注1：VSCode编译器中的终端就是Windows系统中的PowerShell终端或CMD终端，只是VSCode编译器集成了这两个终端，从而使得我们不用在Windows系统中开启PowerShell终端或CMD终端就能执行命令，并且VSCode编译器中的终端在打开时，该终端的路径默认为当前文件的路径，如上图所示。</p>
<p>注2：当创建最基本的Web服务器代码运行在Node.js环境中时，Web服务器就会启动，这时我们就可以在浏览器中输入 <code>http://127.0.0.1</code> IP地址来访问该Web服务器，或者在Web服务器对象中的 <code>listen()</code> 方法中的回调函数中书写 <code>console.log(&#39;http://127.0.0.1&#39;);</code> 代码，将 <code>http://127.0.0.1</code> IP地址输出到终端上，然后使用 <code>Ctrl+鼠标点击</code> 快捷键来点击该地址，就可以自动让浏览器打开该IP地址来访问该Web服务器，并且还可以在终端中使用 <code>Ctrl+C</code> 快捷键来关闭该Web服务器，如上图所示。</p>
</blockquote>
</li>
</ol>
</li>
<li><p>注意点：</p>
<ul>
<li><p>我们还可以使用Postman软件来向我们创建的最基本的Web服务器来发起POST请求，如下图所示：</p>
<p><img src="imgs/22.gif" alt="22"></p>
</li>
<li><p>当我们使用响应对象中的 <code>end()</code> 方法，来向客户端发送中文内容的时候，会出现乱码问题，此时我们需要使用响应对象中的 <code>setHeader()</code> 方法来手动设置内容的编码格式，如以下代码所示：</p>
<pre><code class="lang-javascript">const http = require(&#39;http&#39;);
const server = http.createServer();
server.on(&#39;request&#39;,(req,res) =&gt; {
    // 使用响应对象中的setHeader()方法来手动设置内容的编码格式。
    res.setHeader(&#39;Content-Type&#39;,&#39;text/html; charset=utf-8&#39;);
    const str = `你请求的URL地址是${req.url}，和请求的方式是${req.method}`;
    res.end(str);
});
server.listen(80,() =&gt; {
    console.log(&#39;http server runing at http://127.0.0.1&#39;);
});
</code></pre>
<blockquote>
<p>注：<code>setHeader()</code> 方法中的参数是固定的不需要修改。</p>
</blockquote>
</li>
<li><p>我们还可以根据不同的URL地址来向客户端发送不同的内容，如以下代码所示：</p>
<pre><code class="lang-javascript">const http = require(&#39;http&#39;);
const server = http.createServer();
server.on(&#39;request&#39;,(req,res) =&gt; {
    // 获取请求的url地址。
    const url = req.url;
    // 设置默认的内容为404 Not found。
    let content = &#39;&lt;h1&gt;404 Not found&lt;/h1&gt;&#39;;
    // 判断用户请求的URL地址是否为/URL地址或/index.htmlURL地址或/about.htmlURL地址，然后根据不同的URL地址向客户端发送不同的内容。
    if(url === &#39;/&#39; || url === &#39;/index.html&#39;) {
        content = &#39;&lt;h1&gt;首页&lt;/h1&gt;&#39;;
    } else if(url === &#39;/about.html&#39;) {
        content = &#39;&lt;h1&gt;关于页面&lt;/h1&gt;&#39;;
    }
    // 设置Content-Type响应头，防止中文乱码。
    res.setHeader(&#39;Content-Type&#39;,&#39;text/html; charset=utf-8&#39;);
    // 把内容发送给客户端。
    res.end(content);
});
server.listen(80,() =&gt; {
    console.log(&#39;http server runing at http://127.0.0.1&#39;);
});
</code></pre>
</li>
</ul>
</li>
<li><p>演示代码：</p>
<pre><code class="lang-javascript">const http = require(&#39;http&#39;);
const server = http.createServer();
server.on(&#39;request&#39;,(req,res) =&gt; {
    const url = req.url;
    let content = &#39;&lt;h1&gt;404 Not found&lt;/h1&gt;&#39;;
    if(url === &#39;/&#39; || url === &#39;/index.html&#39;) {
        content = &#39;&lt;h1&gt;首页&lt;/h1&gt;&#39;;
    } else if(url === &#39;/about.html&#39;) {
        content = &#39;&lt;h1&gt;关于页面&lt;/h1&gt;&#39;;
    }
    res.setHeader(&#39;Content-Type&#39;,&#39;text/html; charset=utf-8&#39;);
    res.end(content);
});
server.listen(80,() =&gt; {
    console.log(&#39;http server runing at http://127.0.0.1&#39;);
});
</code></pre>
</li>
<li><p>演示结果：</p>
<p><img src="imgs/23.gif" alt="23"></p>
</li>
</ul>
<h2 id="4-5-web-">4.5实现时钟案例的Web服务器</h2>
<ul>
<li><p>实现时钟案例的Web服务器的实现步骤如下：</p>
<ol>
<li>导入所需模块。</li>
<li>创建基本的Web服务器。</li>
<li>将资源的请求URL地址映射为文件的存放路径。</li>
<li>读取文件的内容并响应给客户端。</li>
</ol>
</li>
<li><p>演示代码：</p>
<pre><code class="lang-javascript">// 导入所需模块。
const fs = require(&#39;fs&#39;);
const path = require(&#39;path&#39;);
const http = require(&#39;http&#39;);
// 创建基本的Web服务器。
const server = http.createServer();
server.on(&#39;request&#39;,(req,res) =&gt; {
    // 将资源的请求URL地址映射为文件的存放路径。
    let fpath = &#39;&#39;;
    if (req.url === &#39;/&#39;) {
        fpath = path.join(__dirname,&#39;./clock/clock.html&#39;);
    } else {
        fpath = path.join(__dirname,&#39;./clock&#39;,req.url);
    }
    // 读取文件的内容并响应给客户端。
    fs.readFile(fpath,&#39;utf8&#39;,(err,dataStr) =&gt; {
        if (err) {
            return res.end(&#39;读取文件失败：&#39; + err.message);
        }
        res.end(dataStr);
    });
});
server.listen(80,() =&gt; {
    console.log(&#39;server is runing at http://127.0.0.1&#39;);
});
</code></pre>
</li>
<li><p>演示结果：</p>
<p><img src="imgs/24.gif" alt="24"></p>
</li>
</ul>
<h1 id="5-">5.模块化</h1>
<h2 id="5-1-">5.1什么是模块化</h2>
<ul>
<li><p>模块化是指解决一个复杂问题时，自顶向下逐层把系统划分成若干模块的过程，对于整个系统来说，模块是可组合、分解和更换的单元。</p>
</li>
<li><p>现实中的模块化，如：小霸王游戏机，它由主机和卡带组成，这样做的好处就是我们需要玩其它游戏的时候只需要更改卡带即可，而不用连主机一起更换。</p>
</li>
<li>编程中的模块化，就是遵守固定的规则，把一个大文件拆分成独立并互相依赖的多个小模块，把代码进行模块化拆分的好处有提高了代码的复用性、提高了代码的可维护性、可以实现按需加载。</li>
</ul>
<h2 id="5-2-">5.2模块化规范</h2>
<ul>
<li>模块化规范就是对代码进行模块化的拆分与组合时，需要遵守的那些规则，如：使用什么样的语法格式来引用模块，在模块中使用什么样的语法格式向外暴露成员。</li>
<li>模块化规范的好处就是大家都遵守同样的模块化规范写代码，降低了沟通的成本，极大方便了各个模块之间的相互调用，利人利己。</li>
</ul>
<h2 id="5-3node-js-">5.3Node.js中的模块化</h2>
<h3 id="5-3-1node-js-">5.3.1Node.js中的模块化的分类</h3>
<ul>
<li>在Node.js中，会根据模块来源的不同，来将模块分为了三大类，分别是：<ul>
<li>内置模块：内置模块是由Node.js官方提供的，如：fs模块、path模块、http模块等。</li>
<li>自定义模块：自定义模块就是用户创建的每个JavaScript文件，都是自定义模块。</li>
<li>第三方模块：第三方模块是由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，在使用第三方模块前需要先下载。</li>
</ul>
</li>
</ul>
<h3 id="5-3-2-">5.3.2加载模块</h3>
<ul>
<li><p>我们可以使用JavaScript中的 <code>require()</code> 方法，来加载需要的内置模块、自定义模块、第三方模块。</p>
</li>
<li><p>语法：</p>
<pre><code class="lang-javascript">// 加载内置模块
const 对象名 = require(&#39;内置模块的模块名&#39;);
// 加载自定义模块
const 对象名 = require(&#39;自定义模块文件的存放路径&#39;);
// 加载第三方模块
const 对象名 = require(&#39;第三方模块的模块名&#39;);
</code></pre>
<blockquote>
<p>注：使用模块前我们需要先使用 <code>require()</code> 方法导入模块，导入模块后，会将模块中的对象返回给 <code>require()</code> 方法，因为该对象没有对象名所以需要通过赋值的方式给其赋对象名，然后我们才能使用该对象中的方法。</p>
</blockquote>
</li>
<li><p>取值：</p>
<p>|                          | 取值                                       |
| :----------------------: | ------------------------------------------ |
|          对象名          | 用户自定义，要遵从变量名的命名规则与规范   |
|     内置模块的模块名     | 用户自定义，只能是内置模块的模块名         |
| 自定义模块文件的存放路径 | 用户自定义，只能是自定义模块文件的存放路径 |
|    第三方模块的模块名    | 用户自定义，只能是第三方模块的模块名       |</p>
</li>
<li><p>注意点：</p>
<ul>
<li>使用 <code>require()</code> 方法加载模块时，会执行被加载模块中的代码。</li>
<li>使用 <code>require()</code> 方法加载自定义模块时，可以省略 <code>.js</code> 后缀名。</li>
</ul>
</li>
<li><p>演示代码之自定义模块：</p>
<pre><code class="lang-javascript">// 07-加载模块.js
console.log(&#39;Hello&#39;);
</code></pre>
</li>
<li><p>演示代码之JavaScript代码文件：</p>
<pre><code class="lang-javascript">// 07-加载模块.js
const zdy = require(&#39;./js/07-加载模块&#39;);
</code></pre>
</li>
<li><p>演示结果：</p>
<p><img src="imgs/25.gif" alt="25"></p>
</li>
</ul>
<h3 id="5-3-3-">5.3.3模块作用域</h3>
<ul>
<li><p>模块作用域和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，在其它模块中是访问不了的，这种模块级别的访问限制，就叫做模块作用域。</p>
</li>
<li><p>模块作用域的好处就是防止了全局变量污染的问题。</p>
</li>
<li><p>演示代码之自定义模块：</p>
<pre><code class="lang-javascript">// 08-模块作用域.js
const num = 1;
function sayHi() {
    console.log(&#39;Hello&#39;);
}
</code></pre>
</li>
<li><p>演示代码之JavaScript代码文件：</p>
<pre><code class="lang-javascript">// 08-模块作用域.js
const zdy = require(&#39;./js/08-模块作用域&#39;);
console.log(num);
sayHi();
</code></pre>
</li>
<li><p>演示结果：</p>
<p><img src="imgs/26.gif" alt="26"></p>
</li>
</ul>
<h3 id="5-3-4-">5.3.4向外共享模块作用域中的成员</h3>
<ul>
<li><p>在每个自定义模块中都有一个 <code>module</code> 对象，该对象存储了当前模块的相关信息，如：当前模块的存放路径，当前模块的模块名等，如下图所示：</p>
<p><img src="imgs/27.gif" alt="27"></p>
</li>
<li><p>在自定义模块中，我们可以使用 <code>module</code> 对象中的 <code>exports</code> 属性，来将当前模块中的成员共享出去，来供外界使用，当外界使用 <code>require()</code> 方法导入该模块时，就会返回该模块中的 <code>module</code> 对象中的 <code>exports</code> 属性所指向的对象给 <code>require()</code> 方法，但是因为在自定义模块中，默认情况下 <code>module</code> 对象中的 <code>exports</code> 属性指向的是一个空对象，所以返回给 <code>require()</code> 方法的是一个空对象，如下图所示：</p>
<p><img src="imgs/28.gif" alt="28"></p>
</li>
<li><p>在自定义模块中，我们可以使用 <code>module</code> 对象中的 <code>exports</code> 属性，来将当前模块中的成员共享出去，来供外界使用，当外界使用 <code>require()</code> 方法导入该模块时，就会返回该模块中的 <code>module</code> 对象中的 <code>exports</code> 属性所指向的对象给 <code>require()</code> 方法，但是因为在自定义模块中，默认情况下 <code>module</code> 对象中的 <code>exports</code> 属性指向的是一个空对象，所以返回给 <code>require()</code> 方法的是一个空对象，这样就导致了不能将当前模块中的成员共享出去，所以为了将当前模块中的成员共享出去，我们可以将当前模块中的成员挂载到 <code>module</code> 对象中的 <code>exports</code> 属性所指向的对象，如下图所示：</p>
<p><img src="imgs/29.gif" alt="29"></p>
</li>
<li><p>注意点：使用 <code>require()</code> 方法导入模块时，导入的结果，永远以导入的模块的 <code>module</code> 对象中的 <code>exports</code> 属性所指向的对象为准。</p>
</li>
<li><p>演示代码之自定义模块：</p>
<pre><code class="lang-javascript">// 09-向外共享模块作用域中的成员.js
const num = 10;
module.exports.name = &#39;张三&#39;;
module.exports.age = num;
module.exports.sayHi = () =&gt; {
    console.log(&#39;Hello&#39;);
}
module.exports = {
    name: &#39;李四&#39;,
    age: num,
    sayHi: () =&gt; {
        console.log(&#39;你好&#39;);
    }
}
</code></pre>
</li>
<li><p>演示代码之JavaScript代码文件：</p>
<pre><code class="lang-javascript">// 09-向外共享模块作用域中的成员.js
const zdy = require(&#39;./js/09-向外共享模块作用域中的成员&#39;);
console.log(zdy);
</code></pre>
</li>
<li><p>演示结果：</p>
<p><img src="imgs/30.gif" alt="30"></p>
</li>
</ul>
<h3 id="5-3-5-exports-">5.3.5 <code>exports</code> 对象</h3>
<ul>
<li><p>为了简化向外共享模块作用域中的成员的代码，Node.js提供了 <code>exports</code> 对象，在自定义模块中，默认情况下 <code>exports</code> 对象          和该模块的 <code>module</code> 对象中的 <code>exports</code> 属性所指向的对象是同一个对象，所以当我们要将该模块中的成员共享出去时，只需将该模块中的成员挂载到 <code>exports</code> 对象上即可，但是要注意最终向外共享的结果，还是以该模块的 <code>module</code> 对象中的 <code>exports</code> 属性所指向的对象为准。</p>
</li>
<li><p>注意点：需时刻谨记，使用 <code>require()</code> 方法导入模块时，导入的结果，永远以导入的模块的 <code>module</code> 对象中的 <code>exports</code> 属性所指向的对象为准，所以为了防止混乱，建议大家不要在同一个模块中同时使用 <code>exports</code> 对象和该模块的 <code>module</code> 对象中的 <code>exports</code> 属性所指向的对象，如以下代码所示：</p>
<pre><code class="lang-javascript">exports.age = 18;
module.exports = {
    age: 20
}
</code></pre>
<blockquote>
<p>注：当以上代码被导入时，会返回 <code>{age: 20}</code> 给 <code>require()</code> 方法。</p>
</blockquote>
<pre><code class="lang-javascript">module.exports.age = 18;
exports = {
    age: 20
}
</code></pre>
<blockquote>
<p>注：当以上代码被导入时，会返回 <code>{age: 18}</code> 给 <code>require()</code> 方法。</p>
</blockquote>
<pre><code class="lang-javascript">module.exports.username = &#39;张三&#39;;
exports.age = 18;
</code></pre>
<blockquote>
<p>注：当以上代码被导入时，会返回 <code>{username: &#39;张三&#39;,aeg: 18}</code> 给 <code>require()</code> 方法。</p>
</blockquote>
<pre><code class="lang-javascript">exports = {
    age: 20
}
module.exports = exports;
module.exports.username = &#39;张三&#39;;
</code></pre>
<blockquote>
<p>注：当以上代码被导入时，会返回 <code>{aeg: 18,username: &#39;张三&#39;}</code> 给 <code>require()</code> 方法。</p>
</blockquote>
</li>
<li><p>演示代码之自定义模块：</p>
<pre><code class="lang-javascript">// 10-exports对象.js
exports.age = 18;
module.exports = {
    age: 20
}
</code></pre>
</li>
<li><p>演示代码之JavaScript代码文件：</p>
<pre><code class="lang-javascript">// 10-exports对象.js
const zdy = require(&#39;./js/10-exports对象&#39;);
console.log(zdy);
</code></pre>
</li>
<li><p>演示结果：</p>
<p><img src="imgs/31.gif" alt="31"></p>
</li>
</ul>
<h3 id="5-3-6node-js-">5.3.6Node.js中的模块化规范</h3>
<ul>
<li>Node.js遵循了CommonJS模块化规范，CommonJS规定了模块的特性和各模块之间是如何相互依赖的。</li>
<li>CommonJS规定：<ul>
<li>每个模块内部都使用 <code>module</code> 变量来代表当前模块。</li>
<li><code>module</code> 变量是一个对象，它的 <code>exports</code> 属性是对外的接口。</li>
<li>当我们使用 <code>require()</code> 方法加载某个模块时，其实是加载该模块的 <code>module</code> 对象中的 <code>exports</code> 属性所指向的对象。</li>
</ul>
</li>
</ul>
<h1 id="6-npm">6.包与npm</h1>
<h2 id="6-1-">6.1包</h2>
<h3 id="6-1-1-">6.1.1什么是包</h3>
<ul>
<li>Node.js中的第三方模块又叫做包，就像电脑和计算机指的是相同的东西，第三方模块和包指的是同一个概念，只不过叫法不同。</li>
</ul>
<h3 id="6-1-2-">6.1.2包的来源</h3>
<ul>
<li>不同于Node.js中的内置模块与自定义模块，包是由第三方个人或团队开发出来的，是免费供所有人使用的。</li>
<li>注意点：Node.js中的包都是免费且开源的，是不需要付费即可免费下载使用的。</li>
</ul>
<h3 id="6-1-3-">6.1.3为什么需要包</h3>
<ul>
<li>由于Node.js的内置模块仅提供了一些底层的API，这导致在基于内置模块进行项目开发时，效率很低，而包是基于内置模块封装出来的，提供了更高级、更方便的API，这极大的提高了开发效率，包和内置模块之间的关系，就类似于jQuery和浏览器内置API之间的关系。</li>
</ul>
<h3 id="6-1-4-">6.1.4从哪里下载包</h3>
<ul>
<li>国外有一家IT公司，叫做npm这家公司旗下有一个非常著名的网站，<a href="https://www.npmjs.com/，它是全球最大的包共享平台，你可以从这个网站上搜索到任何你需要的包，只要你有足够的耐心，到目前为止，全球约1100多万的开发人员，通过这个包共享平台，开发并共享了超过120多万个包供我们使用，npm公司还提供了一个地址为https://registry.npmjs.org/的服务器，来对外共享所有的包，我们可以从这个服务器上下载自己所需要的包。">https://www.npmjs.com/，它是全球最大的包共享平台，你可以从这个网站上搜索到任何你需要的包，只要你有足够的耐心，到目前为止，全球约1100多万的开发人员，通过这个包共享平台，开发并共享了超过120多万个包供我们使用，npm公司还提供了一个地址为https://registry.npmjs.org/的服务器，来对外共享所有的包，我们可以从这个服务器上下载自己所需要的包。</a></li>
</ul>
<h3 id="6-1-5-">6.1.5如何下载包</h3>
<ul>
<li><p>npm公司提供了一个包管理工具，我们可以使用这个包管理工具，来从<a href="https://registry.npmjs.org/服务器把所需要的包下载到本地中使用，这个包管理工具的名字叫做Node">https://registry.npmjs.org/服务器把所需要的包下载到本地中使用，这个包管理工具的名字叫做Node</a> Package Manager，简称npm包管理工具，这个包管理工具会随着Node.js的安装包一起被安装到用户的电脑上，所以大家可以在终端中执行 <code>npm -v</code> 命令，来查看自己电脑上所安装的npm包管理工具的版本号，只要能查看到npm包管理工具的版本号就证明已经安装好了npm包管理工具，如下图所示：</p>
<p><img src="imgs/32.gif" alt="32"></p>
</li>
<li><p>当我们安装了npm包管理工具，就可以在终端中使用 <code>npm install 包的完整名称</code> 命令来下载并安装所需要的包，如下图所示：</p>
<p><img src="imgs/33.gif" alt="33"></p>
<blockquote>
<p>注1：<code>npm install 包的完整名称</code> 命令可以简写成 <code>npm i 包的完整名称</code>，它们的作用是一样的。</p>
<p>注2：如果要在项目中下载并安装包，那么要将终端的路径切换到项目目录下。</p>
</blockquote>
</li>
</ul>
<h2 id="6-2npm-">6.2npm包管理工具初体验</h2>
<ul>
<li><p>当我们使用传统方法来格式化时间的步骤如下：</p>
<ol>
<li>创建格式化时间的自定义模块。</li>
<li>定义格式化时间的方法。</li>
<li>创建补零函数。</li>
<li>从自定义模块中导出格式化时间的函数。</li>
<li>导入格式化时间的自定义模块。</li>
<li>调用格式化时间的函数。</li>
</ol>
</li>
<li><p>演示代码之自定义模块：</p>
<pre><code class="lang-javascript">// 定义格式化时间的方法。
function time(dtStr) {
    const y = bl(dtStr.getFullYear());
    const m = bl(dtStr.getMonth() + 1);
    const d = bl(dtStr.getDate());
    const hh = bl(dtStr.getHours());
    const mm = bl(dtStr.getMinutes());
    const ss = bl(dtStr.getSeconds());
    return `${y}年${m}月${d}日 ${hh}时${mm}分${ss}秒`;
}
// 创建补零函数。
function bl(data) {
    return data &gt; 9 ? data: &#39;0&#39; + data;
}
// 从自定义模块中导出格式化时间的函数。
module.exports = {
    time
}
</code></pre>
</li>
<li><p>演示代码之JavaScript代码文件：</p>
<pre><code class="lang-javascript">// 导入格式化时间的自定义模块。
const zdy = require(&#39;./js/11-npm包管理工具初体验之使用传统的方式格式化时间&#39;);
// 调用格式化时间的函数。
const date = new Date();
console.log(zdy.time(date));
</code></pre>
</li>
<li><p>演示结果：</p>
<p><img src="imgs/34.gif" alt="34"></p>
</li>
<li><p>使用传统方法来格式化时间会很耗时间，我们可以使用高级方法来格式化时间，也就是使用包来格式化时间，步骤如下：</p>
<ol>
<li><p>使用npm包管理工具，在项目中下载并安装格式化时间的包 <code>dayjs</code>，如下图所示：</p>
<p><img src="imgs/35.gif" alt="35"></p>
</li>
<li><p>使用 <code>require()</code> 方法导入格式化时间的包。</p>
</li>
<li><p>参考 <code>dayjs</code> 的官方的API文档来对时间进行格式化。</p>
<blockquote>
<p>注1：查找 <code>dayjs</code> 的官方的API文档，可以在npm包管理工具官网中查找，如下图所示：</p>
<p><img src="imgs/36.gif" alt="36"></p>
<p>注2：npm包管理工具官网为：<a href="https://www.npmjs.com/。">https://www.npmjs.com/。</a></p>
</blockquote>
</li>
</ol>
</li>
<li><p>演示代码：</p>
<pre><code class="lang-javascript">// 使用require()方法导入格式化时间的包。
const date = require(&#39;dayjs&#39;);
// 参考dayjs的官方的API文档来对时间进行格式化。
console.log(date().format(&#39;YYYY-MM-DD HH:mm:ss&#39;));
</code></pre>
</li>
<li><p>演示结果：</p>
<p><img src="imgs/37.gif" alt="37"></p>
</li>
</ul>
<h2 id="6-3-">6.3初次安装包后多了那些文件</h2>
<ul>
<li><p>当在项目中初次下载并安装包，并且安装完成后，在项目文件夹中会多一个文件夹名为node_modules的文件夹和文件名为package-lock.json的配置文件，其中node_modules文件夹是用来存放所有已安装到项目中的包，当使用 <code>require()</code> 方法导入第三方包时，就是从这个目录中查找并加载包，而package-lock.json配置文件是用来记录node_modules文件夹中的每一个包的下载信息，如：包的名字、版本号、下载地址等，如下图所示：</p>
<p><img src="imgs/38.gif" alt="38"></p>
</li>
<li><p>注意点：程序员不要手动修改node_modules文件夹或package-lock.json文件中的任何代码，npm包管理工具会自动维护它们。</p>
</li>
</ul>
<h2 id="6-4-">6.4安装指定版本的包</h2>
<ul>
<li><p>在默认情况下，使用 <code>npm install 包的完整名称</code> 命令下载并安装包的时候，会自动下载并安装最新版本的包，如果需要下载并安装指定版本的包，可以在包名之后，通过@符号来指定具体的版本，如：<code>npm install moment@2.22.0</code>，如下图所示：</p>
<p><img src="imgs/39.gif" alt="39"></p>
</li>
</ul>
<h2 id="6-5-">6.5包的语义化版本规范</h2>
<ul>
<li>包的版本号是以点分十进制的形式来进行定义的，总共有三位数字，如：2.24.0，其中每一位数字所代表的的含义如下：<ul>
<li>第1位数字：代表大版本。</li>
<li>第2位数字：代表功能版本。</li>
<li>第3位数字：代表Bug修复版本。</li>
</ul>
</li>
<li>注意点：版本号提升的规则，只要前面的版本号增长了，则后面的版本号归零，如：1.24.0版本号，如果第一位数字增长了，那么后两位数字都要归零，也就是变成2.0.0。</li>
</ul>
<h2 id="6-6npm-">6.6npm包管理工具的配置文件</h2>
<ul>
<li>npm包管理工具规定，在项目根目录中，必须提供一个文件名为package.json的包管理配置文件，该文件是用来记录与项目有关的一些配置信息，如：项目的名称、版本号、描述等，项目中都用到了哪些包，哪些包只在开发期间会用到，那些包在开发和部署时都需要用到。</li>
</ul>
<h3 id="6-6-1-">6.6.1多人协作的问题</h3>
<ul>
<li>假设整个项目的体积是30.4M，第三方包的体积是28.8M，那么项目源代码的体积就是1.6M，此时遇到的问题是第三方包的体积过大，不方便团队成员之间共享项目源代码，所以我们使用Git版本控制工具共享项目源代码时，应该剔除node_modules文件夹。</li>
</ul>
<h3 id="6-6-2-">6.6.2如何记录项目中安装了哪些包</h3>
<ul>
<li>当我们在团队成员之间共享项目源代码时，已经剔除了node_modules文件夹，那么其它团队成员就不知道该项目使用了那些包，此时我们可以在项目根目录中，创建一个文件名为package.json的配置文件，用该文件来记录该项目中安装了哪些包，从而解决上述问题。</li>
<li>注意点：今后在共享项目源代码时，一定要把node_modules文件夹，添加到.gitignore忽略文件中。</li>
</ul>
<h3 id="6-6-3-package-json-">6.6.3快速创建package.json配置文件</h3>
<ul>
<li><p>npm包管理工具提供了 <code>npm init -y</code> 命令，我们可以在终端中执行该命令，来快速创建package.json这个包管理配置文件，如下图所示：</p>
<p><img src="imgs/40.gif" alt="40"></p>
<blockquote>
<p>注：如果要在项目中快速创建package.json这个包管理配置文件，那么要将终端的路径切换到项目目录下。</p>
</blockquote>
</li>
<li><p>注意点：</p>
<ul>
<li><p><code>npm init -y</code> 命令只能在英文的目录下成功运行，所以项目文件夹的名称一定要使用英文命名，不要使用中文，并且不能出现空格。</p>
</li>
<li><p>运行 <code>npm install 包的完整名称</code> 命令下载并安装包时，npm包管理工具会自动把包的名称和版本号，记录到package.json配置文件中，如下图所示：</p>
<p><img src="imgs/41.gif" alt="41"></p>
</li>
</ul>
</li>
</ul>
<h3 id="6-6-4-dependencies-">6.6.4 <code>dependencies</code> 节点</h3>
<ul>
<li><p>在package.json配置文件中，有一个 <code>dependencies</code> 节点，该节点是专门用来记录在项目中使用了 <code>npm install 包的完整名称</code> 命令下载并安装了哪些包的，如下图所示：</p>
<p><img src="imgs/42.gif" alt="42"></p>
</li>
</ul>
<h3 id="6-6-5-">6.6.5一次性下载并安装所有的包</h3>
<ul>
<li><p>当我们拿到了一个剔除了node_modules文件夹的项目后，我们需要先把所有的包下载并安装到项目中，才能将项目运行起来，否则会报错，如下图所示：</p>
<p><img src="imgs/43.gif" alt="43"></p>
</li>
<li><p>当我们拿到了一个剔除了node_modules文件夹的项目后，我们需要先把所有的包下载并安装到项目中，才能将项目运行起来，我们可以在项目中打开终端，并且在终端中使用 <code>npm install</code> 命令或者 <code>npm i</code> 命令来一次性下载并安装所有的依赖包，一次性下载并安装所有的包的原理是当在终端中执行 <code>npm install</code> 命令时，npm包管理工具会先读取项目中的package.json配置文件中的 <code>dependencies</code> 节点，当读取到该节点记录的所有的依赖包名称和版本号后，npm包管理工具会把这些包一次性下载并安装到项目中，如下图所示：</p>
<p><img src="imgs/44.gif" alt="44"></p>
</li>
</ul>
<h3 id="6-6-6-">6.6.6卸载包</h3>
<ul>
<li><p>当我们想删除项目中的某个包时，我们可以在项目中打开终端，并且在终端中执行 <code>npm uninstall 要删除的包的完整名称</code> 命令，来删除项目中指定的包，如以下代码所示：</p>
<p><img src="imgs/45.gif" alt="45"></p>
<blockquote>
<p>注：当终端执行完 <code>npm uninstall 要删除的包的完整名称</code> 命令后，会把删除的包，自动从项目中的package.json配置文件中的 <code>dependencies</code> 节点中移除掉。</p>
</blockquote>
</li>
</ul>
<h3 id="6-6-7-devdependencies-">6.6.7 <code>devDependencies</code> 节点</h3>
<ul>
<li><p>如果某些包只在项目开发阶段中会用到，在项目上线后不会用到，则建议把这些包记录到项目中的package.json配置文件中的 <code>devDependencies</code> 节点中，与之对应的，如果某些包在开发和项目上线之后都需要用到，则建议把这些包记录到项目中的package.json配置文件中的 <code>dependencies</code> 节点中。</p>
</li>
<li><p>我们可以在项目中打开终端，并且在终端中使用 <code>npm install 包的完整名称 --save-dev</code> 命令或使用该命令的简写形式 <code>npm i 包的完整名称 -D</code>，将包下载并安装，并且将包记录到项目中的package.json配置文件中的 <code>devDependencies</code> 节点中，如下图所示：</p>
<p><img src="imgs/46.gif" alt="46"></p>
</li>
</ul>
<h2 id="6-7-">6.7解决下载包速度慢的问题</h2>
<h3 id="6-7-1-">6.7.1为什么下载包速度慢</h3>
<ul>
<li><p>在使用npm包管理工具下载并安装包时，默认是从国外的<a href="https://registry.npmjs.org/服务器进行下载，此时网络数据的传输需要经过漫长的海底光缆，因此下载包的速度会很慢，为了解决这个问题我们可以切换npm包管理工具的下载包的镜像源。">https://registry.npmjs.org/服务器进行下载，此时网络数据的传输需要经过漫长的海底光缆，因此下载包的速度会很慢，为了解决这个问题我们可以切换npm包管理工具的下载包的镜像源。</a></p>
<blockquote>
<p>注：切换npm包管理工具的下载包的镜像源就是切换npm包管理工具的下载包的服务器地址。</p>
</blockquote>
</li>
</ul>
<h3 id="6-7-2-npm-">6.7.2淘宝npm镜像服务器</h3>
<ul>
<li><p>淘宝在国内搭建了一个服务器，专门把国外官方服务器上的包同步到国内的服务器上，然后在国内提供下载包的服务，从而极大的提高了下载包的速度。</p>
<blockquote>
<p>注：镜像（Mirroring）是一种文件存储的形式，如：一个磁盘上的数据，在另一个磁盘上存在一个完全相同的副本即为镜像。</p>
</blockquote>
</li>
<li><p>从淘宝npm镜像服务器中下载包，如下图所示：</p>
<p><img src="imgs/47.png" alt="47"></p>
</li>
<li><p>从官网服务器中下载包，如下图所示：</p>
<p><img src="imgs/48.png" alt="48"></p>
</li>
<li><p>注意点：在安装新版本的Node.js时，npm包管理工具也会被一起安装，并且npm包管理工具的下载包的镜像源已经被切换到了淘宝npm镜像服务器。</p>
</li>
</ul>
<h3 id="6-7-3-npm-">6.7.3切换npm包管理工具的下载包的镜像源</h3>
<ul>
<li><p>我们可以在终端中使用 <code>npm config get registry</code> 命令，来查看当前npm包管理工具的下载包的镜像源，如下图所示：</p>
<p><img src="imgs/49.gif" alt="49"></p>
</li>
<li><p>我们可以在终端中使用 <code>npm config set registry=要切换的镜像源</code> 命令，来切换当前npm包管理工具的下载包的镜像源，如下图所示：</p>
<p><img src="imgs/50.gif" alt="50"></p>
<blockquote>
<p>注：上图中是将npm包管理工具的下载包的镜像源切换到了官方服务器，因为在安装新版本的Node.js时，npm包管理工具也会被一起安装，并且npm包管理工具的下载包的镜像源已经被切换到了淘宝npm镜像服务器。</p>
</blockquote>
</li>
</ul>
<h3 id="6-7-4nrm">6.7.4nrm</h3>
<ul>
<li><p>为了更方便的切换npm包管理工具的下载包的镜像源，我们可以在终端中执行 <code>npm instal nrm open@8.4.2 -g</code> 命令，来安装nrm这个小工具，然后再利用nrm提供的 <code>nrm ls</code> 命令，来快速查看npm包管理工具的下载包的镜像源，如下图所示：</p>
<p><img src="imgs/51.gif" alt="51"></p>
<blockquote>
<p>注：当我们使用 <code>nrm ls</code> 命令，来快速查看npm包管理工具的下载包的镜像源时，会发现没有星号提示当前npm包管理工具的下载包的镜像源是那个，此时我们可以打开 <code>C:\用户\用户名文件夹\AppData\Roaming\npm\node_modules\nrm</code> 目录下的cli.js文件，修改该文件中的第141行代码，将 <code>&amp;&amp;</code> 修改成 <code>||</code> 即可解决上述问题，如下图所示：</p>
<p><img src="imgs/52.gif" alt="52"></p>
</blockquote>
</li>
<li><p>当我们安装了nrm这个小工具后，我们可以在终端中执行 <code>nrm use 要切换的镜像源的完整名称</code> 命令，来切换当前npm包管理工具的下载包的镜像源，如下图所示：</p>
<p><img src="imgs/53.gif" alt="53"></p>
</li>
</ul>
<h2 id="6-8-">6.8包的分类</h2>
<ul>
<li><p>使用npm包管理工具下载的包，共分为两大类，分别是：</p>
<ul>
<li><p>项目包：</p>
<ul>
<li>那些被安装到项目的node_modules文件夹中的包，都是项目包。</li>
<li>项目包又分为两类，分别是：<ul>
<li>开发依赖包：被记录到项目中的package.json配置文件中的 <code>dependencies</code> 节点中的包，只在开发期间会用到，使用 <code>npm i 包的完整名称 -D</code> 命令安装的包都是开发依赖包。</li>
<li>核心依赖包：被记录到项目中的package.json配置文件中的 <code>devDependencies</code> 节点中的包，在开发期间和项目上线之后都会用到，使用 <code>npm i 包的完整名称</code> 命令安装的包都是核心依赖包。</li>
</ul>
</li>
</ul>
</li>
<li><p>全局包：</p>
<ul>
<li><p>当在中终端中使用 <code>npm install 包的完整名称</code> 命令时，如果提供了参数 <code>-g</code>，那么该命令就会下载包并将包安装为全局包，如下图所示：</p>
<p><img src="imgs/54.gif" alt="54"></p>
<blockquote>
<p>注：全局包会被安装到 <code>C:\用户\用户名文件夹\AppData\Roaming\npm\node_modules</code> 目录下。</p>
</blockquote>
</li>
<li><p>我们还可以在终端中使用 <code>npm install 要删除的包的完整名称 -g</code> 命令，来删除全局包，如下图所示：</p>
<p><img src="imgs/55.gif" alt="55"></p>
</li>
<li><p>注意点：只有工具性质的包，才有全局安装的必要性，因为它们提供了好用的终端命令，要判断某个包是否需要全局安装后才能使用，可以参考官方提供的使用说明即可，如下图所示：</p>
<p><img src="imgs/56.gif" alt="56"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="6-9i5ting_toc">6.9i5ting_toc</h2>
<ul>
<li><p>i5ting_toc是一个可以把MD文档转为HTML页面的小工具，使用步骤如下：</p>
<ol>
<li><p>将i5ting_toc安装为全局包，如下图所示：</p>
<p><img src="imgs/57.gif" alt="57"></p>
</li>
<li><p>在项目中打开终端，并且在终端中使用 <code>i5ting_toc -f 要转换的MD文件的路径 -o</code> 命令，来将MD文档转换为HMTL页面，其中 <code>-o</code> 参数表示转换完成后自动打开HTML页面，如下图所示：</p>
</li>
</ol>
</li>
</ul>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>